import os
import vcfpy
import subprocess
import argparse

    """## _summary_
    THis script will lift over a VCF file for CNV generated by gCNV from GATK
    ### Returns:
        - `_type_`: _description_
        The command is the following:
            python Liftover_and_gvf.py -i input.vcf -o output_hg19.vcf -g output_hg19.gvf
    """

# Define paths
LIFTOVER_BIN = "/home/nawar82/code/nawar82/KB4111/CNV_liftover_gvf/liftOver"  # Path to liftOver binary
CHAIN_FILE = "/home/nawar82/code/nawar82/KB4111/CNV_liftover_gvf/hg38ToHg19.over.chain.gz"  # Path to liftover chain file

# Function to lift over a single position
def liftover_position(chrom, pos):
    """Lifts over a genomic position using UCSC liftOver tool."""
    input_file = "tmp_liftover_input.bed"
    output_file = "tmp_liftover_output.bed"
    unlifted_file = "tmp_unlifted.bed"

    # Create BED file for liftover
    with open(input_file, "w") as f:
        f.write(f"{chrom}\t{pos-1}\t{pos}\n")  # BED format (0-based start)

    # Run liftOver
    cmd = [LIFTOVER_BIN, input_file, CHAIN_FILE, output_file, unlifted_file]
    subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    # Parse output
    try:
        with open(output_file) as f:
            for line in f:
                tokens = line.strip().split("\t")
                return tokens[0], int(tokens[1]) + 1  # Convert back to 1-based
    except FileNotFoundError:
        return None, None

def write_gvf_header(output_gvf):
    """Writes the GVF file header, including column names."""
    with open(output_gvf, "w") as gvf_out:
        gvf_out.write("##gff-version 3\n")
        gvf_out.write("##gvf-version 1.10\n")
        gvf_out.write("##species Homo sapiens\n")
        gvf_out.write("##genome-build hg19\n")  # Assuming hg19 after liftover
        gvf_out.write("##source GATK\n")
        gvf_out.write("##attribute-definition ID Unique identifier for the variant\n")
        gvf_out.write("##attribute-definition Reference_seq The reference sequence\n")

        # GVF column headers (Requested!)
        gvf_out.write("#seqid\tsource\ttype\tstart\tend\tscore\tstrand\tphase\tattributes\n")


# Function to process VCF
def process_vcf(input_vcf, output_vcf, output_gvf):

    # First, write the GVF header
    write_gvf_header(output_gvf)

    """Reads CNV VCF, performs liftover, and converts to GVF."""
    reader = vcfpy.Reader.from_path(input_vcf)
    header = reader.header
    writer = vcfpy.Writer.from_path(output_vcf, header)

    with open(output_gvf, "a") as gvf_out:

        for record in reader:
            chrom = record.CHROM
            start_hg38 = record.POS
            id_field = record.ID[0] if record.ID else ""  # Expected format: CNV_chr_start_end and handles missing IDs

            # Parse CNV ID field
            if id_field.startswith("CNV_"):
                _, chrom_str, start_str, end_str = id_field.split("_")
                start_pos = int(start_str)
                end_pos = int(end_str)
            else:
                start_pos = start_hg38
                end_pos = start_hg38  # Default to a single position if malformed

            # LiftOver the positions
            chrom_hg19, start_hg19 = liftover_position(chrom, start_hg38)
            _, start_liftover = liftover_position(chrom, start_pos)
            _, end_liftover = liftover_position(chrom, end_pos)

            # Skip if liftover failed
            if None in (chrom_hg19, start_hg19, start_liftover, end_liftover):
                continue

            # Update VCF entry
            record.CHROM = chrom_hg19
            record.POS = start_hg19
            record.ID = [f"CNV_{chrom_hg19}_{start_liftover}_{end_liftover}"] # Keep ID as a list
            # Update INFO END field
            if "END" in record.INFO:
                record.INFO["END"] = end_liftover

            writer.write_record(record)

            # Convert to GVF format
            #gvf_out.write(f"{chrom_hg19}\t.\tCNV\t{start_liftover}\t{end_liftover}\t.\t.\tID={record.ID};Variant_effect=CNV\n")

            # Extract necessary fields
            source = "GATK"
            variant_type = record.ALT[0].value if record.ALT else "."  # Use ALT for type
            score = record.QUAL if record.QUAL is not None else "."  # Use QUAL if available
            strand = "."
            phase = "."
            reference_seq = record.REF  # REF column
            id_value = f"CNV_{chrom_hg19}_{start_liftover}_{end_liftover}"  # Updated ID

            # Construct attributes field
            attributes = f"ID={id_value};Reference_seq={reference_seq}"

            # Write GVF record
            gvf_out.write(f"{chrom_hg19}\t{source}\t{variant_type}\t{start_liftover}\t{end_liftover}\t{score}\t{strand}\t{phase}\t{attributes}\n")

    writer.close()

# Command-line argument parsing
parser = argparse.ArgumentParser(description="Liftover CNV VCF from hg38 to hg19 and convert to GVF")
parser.add_argument("-i", "--input", required=True, help="Path to input VCF file")
parser.add_argument("-o", "--output_vcf", default="output_hg19.vcf", help="Path to output VCF file")
parser.add_argument("-g", "--output_gvf", default="output.gvf", help="Path to output GVF file")
args = parser.parse_args()

# Run process
process_vcf(args.input, args.output_vcf, args.output_gvf)
