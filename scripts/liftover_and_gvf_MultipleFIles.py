import os
import vcfpy
import subprocess
import argparse

"""
Liftover CNV VCF Files from hg38 to hg19 and Convert to GVF

This script automates the processing of Copy Number Variation (CNV) VCF files generated
by GATK gCNV. It can optionally perform liftover from hg38 to hg19 and convert
the VCF data into GVF format.

### Features:
- Reads a list of VCF file paths from an input text file.
- Optionally performs liftover of CNV regions using the UCSC liftOver tool.
- Updates CNV IDs and the INFO field (`END` attribute) to reflect hg19 coordinates.
- Generates output files with `_hg19.gvf` suffix.
- Skips missing files and provides warnings.
- Applies CN filtering rules only to `chrX`, depending on the sample's sex:
  - **Males (`chrX`)**:
    - CN == 1 variants are skipped.
    - CN == 0 is classified as `DEL`.
    - CN â‰¥ 2 is classified as `DUP`.
  - **Females (`chrX`)**:
    - CN == 2 variants are skipped.

### Dependencies:
- Python libraries: `vcfpy`, `argparse`, `subprocess`
- External tools: UCSC `liftOver` (if liftover is enabled)
- Required files:
    - UCSC chain file for hg38 to hg19 conversion (`hg38ToHg19.over.chain.gz`)
    - Valid CNV VCF files generated by gCNV tool

### Usage:
1. Prepare a text file (e.g., `file_list.txt`) listing the paths to VCF files, one per line.
2. Run the script with liftover enabled (default):
```bash
python Liftover_and_gvf.py -i file_list.txt
```
3. Run the script without liftover (for hg19 VCFs):
```bash
python Liftover_and_gvf.py -i file_list.txt --no-liftover
```

Developed by Nawar Dalila
"""
# Get the directory of the script
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))

# Define relative paths
LIFTOVER_BIN = os.path.join(SCRIPT_DIR, "helper", "liftOver")
CHAIN_FILE = os.path.join(SCRIPT_DIR, "helper", "hg38ToHg19.over.chain.gz")
RESULTS_DIR = os.path.join(SCRIPT_DIR, "..", "test_data", "results")
TEMP_DIR = os.path.join(SCRIPT_DIR, "..", "test_data", "temp")

# Ensure results directory exists
os.makedirs(RESULTS_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)

def extract_sex_from_sample(sample_name):
    """Extracts sex information from the sample name."""
    identifier = sample_name.split("-")[0]
    return "male" if identifier.endswith("m") else "female"

def liftover_position(chrom, pos):
    """Lifts over a genomic position using UCSC liftOver tool."""
    input_file = os.path.join(TEMP_DIR, "tmp_liftover_input.bed")
    output_file = os.path.join(TEMP_DIR, "tmp_liftover_output.bed")
    unlifted_file = os.path.join(TEMP_DIR, "tmp_unlifted.bed")

    with open(input_file, "w") as f:
        f.write(f"{chrom}\t{pos-1}\t{pos}\n")

    cmd = [LIFTOVER_BIN, input_file, CHAIN_FILE, output_file, unlifted_file]
    subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    try:
        with open(output_file) as f:
            for line in f:
                tokens = line.strip().split("\t")
                return tokens[0], int(tokens[1]) + 1
    except FileNotFoundError:
        return None, None

def write_gvf_header(output_gvf):
    """Writes the GVF file header."""
    with open(output_gvf, "w") as gvf_out:
        gvf_out.write("##gff-version 3\n")
        gvf_out.write("##gvf-version 1.10\n")
        gvf_out.write("##species Homo sapiens\n")
        gvf_out.write("##genome-build hg19\n")
        gvf_out.write("##source GATK_PostprocessGermlineCNVCalls\n")
        gvf_out.write("##attribute-definition ID Unique identifier for the variant\n")
        gvf_out.write("##attribute-definition Reference_seq The reference sequence\n")
        gvf_out.write("##attribute-definition Genotype Genotype of the segment\n")
        gvf_out.write("##attribute-definition Copy_number Copy number of the segment\n")
        gvf_out.write("##attribute-definition Num_points Number of points in the segment\n")
        gvf_out.write("#seqid\tsource\ttype\tstart\tend\tscore\tstrand\tphase\tattributes\n")

def process_vcf(input_vcf, output_gvf):
    """Reads CNV VCF, performs liftover, and converts to GVF."""
    write_gvf_header(output_gvf)

    reader = vcfpy.Reader.from_path(input_vcf)

    with open(output_gvf, "a") as gvf_out:
        for record in reader:
            chrom = record.CHROM
            start_hg38 = record.POS
            id_field = record.ID[0] if record.ID else ""

            if id_field.startswith("CNV_"):
                _, chrom_str, start_str, end_str = id_field.split("_")
                start_pos = int(start_str)
                end_pos = int(end_str)
            else:
                start_pos = start_hg38
                end_pos = start_hg38

            if LIFTOVER_ENABLED:
                chrom_hg19, start_hg19 = liftover_position(chrom, start_hg38)
                _, start_liftover = liftover_position(chrom, start_pos)
                _, end_liftover = liftover_position(chrom, end_pos)

                if None in (chrom_hg19, start_hg19, start_liftover, end_liftover):
                    continue
            else:
                # No liftover: keep hg38 values as they are
                chrom_hg19, start_hg19 = chrom, start_hg38
                start_liftover, end_liftover = start_pos, end_pos

            source = "GATK_PostprocessGermlineCNVCalls"
            variant_type = record.ALT[0].value if record.ALT else "."

            if variant_type == "." and chrom_hg19 != "chrX":            # Keep only CNVs with an event and everything in chrX for further logic
                continue

            score = record.QUAL if record.QUAL is not None else "."
            strand = "."
            phase = "."
            reference_seq = record.REF
            id_value = f"CNV_{chrom_hg19}_{start_liftover}_{end_liftover}"

            # Extract GT, CN, and NP values
            sample_calls = record.calls[0].data         # basically calls[0] list is a Call class that has data as an attribute
            gt = sample_calls["GT"]
            cn = sample_calls["CN"]
            np = sample_calls["NP"]

            sample_name = record.calls[0].sample
            sample_sex = extract_sex_from_sample(sample_name)
            if chrom_hg19 == "chrX":
                if sample_sex == "male":
                    if cn == 1:
                        continue  # Skip this variant for males with CN == 1
                    elif cn == 0:
                        variant_type = "DEL"
                    elif cn >= 2:
                        variant_type = "DUP"
                if sample_sex == "female":
                    if cn == 2:
                        continue  # Skip this variant for males with CN == 1

            attributes = f"ID={id_value};Reference_seq={reference_seq};Genotype={gt};Copy_number={cn};Num_points:{np};sample:{sample_name}"
            gvf_out.write(f"{chrom_hg19}\t{source}\t{variant_type}\t{start_liftover}\t{end_liftover}\t{score}\t{strand}\t{phase}\t{attributes}\n")


# Command-line argument parsing
parser = argparse.ArgumentParser(description="Liftover CNV VCF from hg38 to hg19 and convert to GVF")
parser.add_argument("-i", "--input", required=True, help="Path to file containing list of CNV VCF files generated by gCNV tool from GATK")
parser.add_argument("--no-liftover", action="store_true", help="Disable liftover if the input VCF is already in hg19")
args = parser.parse_args()

# Set liftover based on the argument
LIFTOVER_ENABLED = not args.no_liftover

if __name__ == "__main__":
    # Read input file list
    with open(args.input, "r") as f:
        vcf_files = [line.strip() for line in f if line.strip()]

    # Process each VCF file
    for vcf_file in vcf_files:
        if not os.path.exists(vcf_file):
            print(f"Warning: {vcf_file} not found, skipping...")
            continue

        base_name = os.path.splitext(os.path.basename(vcf_file))[0]
        output_gvf = os.path.join(RESULTS_DIR, f"{base_name}_hg19.gvf")

        print(f"Processing {vcf_file} -> {output_gvf} (Liftover: {'Enabled' if LIFTOVER_ENABLED else 'Disabled'})")
        process_vcf(vcf_file, output_gvf)

    print("Processing complete!")
##END
